<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Upload books • Spellcaster Portal</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;margin:0;background:#0b0f16;color:#e8eefc}
    a{color:#9ecbff}
    .wrap{max-width:980px;margin:0 auto;padding:18px}
    .card{background:#121a2a;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:16px;margin:12px 0}
    h1{font-size:22px;margin:0 0 6px}
    h2{font-size:16px;margin:0 0 10px;opacity:.95}
    p{margin:8px 0;opacity:.9;line-height:1.35}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input,button,select{border-radius:10px;border:1px solid rgba(255,255,255,.14);background:#0e1524;color:#e8eefc;padding:10px 12px}
    input{flex:1;min-width:220px}
    button{cursor:pointer}
    button:disabled{opacity:.5;cursor:not-allowed}
    .muted{opacity:.75;font-size:.92rem}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.9rem;white-space:pre-wrap}
    .ok{color:#7dffa6}
    .warn{color:#ffd37d}
    .err{color:#ff8a8a}
    .sep{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Sentinel Suite</h1>
      <div class="muted">Portal • Journal • Audio • Legacy Tools</div>
    </div>

    <div class="card">
      <h2>Upload books</h2>
      <p>Browsers still upload folders as a per‑file queue. If you already have files on the server (Google Drive sync or disk), use <b>Scan & ingest</b> below.</p>

      <div class="row">
        <input id="files" type="file" multiple />
        <button id="btnUpload">Upload selected files</button>
      </div>

      <div class="sep"></div>

      <h2>Scan & ingest from a server folder</h2>
      <p class="muted">Set the folder path that contains your uploaded/synced files. Default is <code>/data/spellcaster_uploads</code>. This will scan subfolders and ingest one file at a time.</p>

      <div class="row">
        <input id="sourceDir" value="/data/spellcaster_uploads" />
        <button id="btnIngest">Scan & ingest</button>
        <button id="btnIngestStatus">Check ingest status</button>
      </div>

      <div id="ingestBox" class="mono muted" style="margin-top:10px;">Waiting…</div>

      <div class="sep"></div>

      <h2>Reindex library</h2>
      <p class="muted">After ingest completes, reindex. You can also run the full flow automatically.</p>

      <div class="row">
        <button id="btnReindex">Reindex now</button>
        <select id="waitSeconds">
          <option value="15">Wait 15s</option>
          <option value="30" selected>Wait 30s</option>
          <option value="60">Wait 60s</option>
        </select>
        <button id="btnAuto">Ingest → wait → reindex</button>
      </div>

      <div id="reindexBox" class="mono muted" style="margin-top:10px;">Ready.</div>
    </div>

    <div class="card">
      <h2>Quick links</h2>
      <div class="row">
        <a href="/" rel="nofollow">Home</a>
        <a href="/upload" rel="nofollow">Upload</a>
        <a href="/uploads" rel="nofollow">Uploads (alt)</a>
        <a href="/reindex_status" rel="nofollow">Reindex status</a>
      </div>
    </div>
  </div>

<script>
const el = (id) => document.getElementById(id);
const ingestBox = el("ingestBox");
const reindexBox = el("reindexBox");

let ingestPoll = null;
let reindexPoll = null;

async function postJSON(url, data){
  const r = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(data||{})});
  const t = await r.text();
  return {ok:r.ok, status:r.status, text:t};
}

async function getJSON(url){
  const r = await fetch(url, {cache:"no-store"});
  const t = await r.text();
  try { return {ok:r.ok, status:r.status, json: JSON.parse(t), text:t}; }
  catch { return {ok:r.ok, status:r.status, json:null, text:t}; }
}

function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

async function refreshIngestStatus(){
  const s = await getJSON("/api/library/ingest_status");
  if(!s.ok){
    ingestBox.className = "mono err";
    ingestBox.textContent = s.text || ("Failed to fetch ingest status ("+s.status+")");
    return null;
  }
  ingestBox.className = "mono muted";
  ingestBox.textContent = JSON.stringify(s.json, null, 2);
  return s.json;
}

async function startIngest(){
  ingestBox.className = "mono muted";
  ingestBox.textContent = "Starting ingest…";
  const source_dir = el("sourceDir").value.trim();
  const r = await postJSON("/api/library/ingest", {source_dir});
  if(!r.ok){
    ingestBox.className = "mono err";
    ingestBox.textContent = r.text || "Failed to start ingest.";
    return;
  }
  ingestBox.textContent = "Ingest started. Polling…\n" + r.text;
  if(ingestPoll) clearInterval(ingestPoll);
  ingestPoll = setInterval(refreshIngestStatus, 2000);
  await refreshIngestStatus();
}

async function refreshReindexStatus(){
  const s = await getJSON("/reindex_status");
  if(!s.ok){
    reindexBox.className = "mono err";
    reindexBox.textContent = s.text || ("Failed to fetch reindex status ("+s.status+")");
    return null;
  }
  const j = s.json || {};
  reindexBox.className = "mono muted";
  reindexBox.textContent = (j.running ? "RUNNING: " : "STATUS: ") + (j.message || "") + "\n" + JSON.stringify(j, null, 2);
  return j;
}

async function startReindex(){
  reindexBox.className = "mono muted";
  reindexBox.textContent = "Starting reindex…";
  const r = await postJSON("/api/reindex", {});
  if(!r.ok){
    reindexBox.className = "mono err";
    reindexBox.textContent = r.text || "Failed to start reindex.";
    return;
  }
  reindexBox.textContent = "Reindex request sent. Polling…\n" + r.text;
  if(reindexPoll) clearInterval(reindexPoll);
  reindexPoll = setInterval(refreshReindexStatus, 2000);
  await refreshReindexStatus();
}

async function autoFlow(){
  await startIngest();

  // wait for ingest to finish
  const start = Date.now();
  const timeoutMs = 30 * 60 * 1000;
  while(true){
    const st = await refreshIngestStatus();
    if(st && st.running === false) break;
    if(Date.now() - start > timeoutMs) break;
    await sleep(2000);
  }

  const wait = parseInt(el("waitSeconds").value, 10) || 30;
  reindexBox.className = "mono muted";
  reindexBox.textContent = "Waiting " + wait + " seconds before reindex…";
  await sleep(wait * 1000);

  await startReindex();
}

el("btnIngest").addEventListener("click", startIngest);
el("btnIngestStatus").addEventListener("click", refreshIngestStatus);
el("btnReindex").addEventListener("click", startReindex);
el("btnAuto").addEventListener("click", autoFlow);

el("btnUpload").addEventListener("click", async () => {
  const files = el("files").files;
  if(!files || !files.length){
    ingestBox.className="mono warn";
    ingestBox.textContent="No files selected.";
    return;
  }
  const fd = new FormData();
  for(const f of files){ fd.append("files", f, f.webkitRelativePath || f.name); }
  ingestBox.className="mono muted";
  ingestBox.textContent="Uploading " + files.length + " file(s)…";
  const r = await fetch("/api/upload", {method:"POST", body:fd});
  const t = await r.text();
  ingestBox.textContent = "Upload response ("+r.status+"): \n" + t + "\n\nThen click Scan & ingest, then Reindex.";
});
</script>
</body>
</html>
